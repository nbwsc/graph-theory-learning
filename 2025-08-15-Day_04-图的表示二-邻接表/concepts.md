# Day 4: 图的表示（二）——邻接表 (Adjacency List)

## 1. 什么是邻接表 (Adjacency List)？

邻接表是另一种广泛使用的图存储结构。其核心思想是为图中的每一个顶点创建一个列表，这个列表里包含了所有与该顶点直接相连的其他顶点。

- **无向图 (Undirected Graph)**: 如果顶点 A 和 B 之间有边，则 A 的邻接表中包含 B，B 的邻接表中也包含 A。
- **有向图 (Directed Graph)**: 如果存在从 A 指向 B 的边，则只在 A 的邻接表中添加 B。

这种结构非常适合表示稀疏图（边的数量远小于顶点数量平方的图）。

## 2. 如何实现邻接表？

在 Python 中，通常使用字典（Dictionary）和列表（List）的组合来实现邻接表。字典的键是顶点，值是该顶点的邻居列表。

### 示例 1：无向图

一个包含顶点 `A, B, C, D` 和边 `(A, B), (A, C), (B, C), (B, D), (C, D)` 的无向图可以表示为：

```python
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'C', 'D'],
    'C': ['A', 'B', 'D'],
    'D': ['B', 'C']
}
```

### 示例 2：加权图 (Weighted Graph)

对于加权图，邻接列表中的元素通常是一个元组 `(邻居, 权重)`。

一个包含边 `A --(7)--> B` 和 `A --(3)--> C` 的加权有向图可以表示为：

```python
weighted_graph = {
    'A': [('B', 7), ('C', 3)],
    'B': [],
    'C': []
}
```

## 3. 邻接表的优缺点

### 优点

1.  **空间效率高**: 对于稀疏图，邻接表比邻接矩阵占用空间少得多。其空间复杂度为 **O(V + E)**，其中 V 是顶点数，E 是边数。
2.  **高效遍历邻居**: 查找并遍历一个顶点的所有邻居非常方便快捷，时间复杂度为 O(k)，其中 k 是该顶点的度（degree）。

### 缺点

1.  **查询特定边效率较低**: 判断两个顶点之间是否存在边的效率不如邻接矩阵。需要遍历其中一个顶点的邻接列表来查找另一个顶点，时间复杂度为 O(k)。

## 4. 邻接矩阵 vs. 邻接表

| 特性 | 邻接矩阵 (Adjacency Matrix) | 邻接表 (Adjacency List) |
| :--- | :--- | :--- |
| **空间复杂度** | O(V²) | O(V + E) |
| **查询两点间是否存在边** | O(1) | O(k) (k是点的度) |
| **遍历一个点的所有邻边** | O(V) | O(k) (k是点的度) |
| **适用场景** | 稠密图 (Dense Graph) | 稀疏图 (Sparse Graph) |
